"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const service_decorator_1 = require("../decorators/services/service.decorator");
const name_decorator_1 = require("../decorators/services/name.decorator");
const server_1 = require("../server/server");
const server_2 = require("../metadata/server/server");
const orm_1 = require("../metadata/server/orm");
const logger_1 = require("./logger");
const cin_1 = require("../util/cin");
const cout_1 = require("../util/cout");
const direct_logger_1 = require("../util/direct-logger");
const delay_1 = require("../util/delay");
const vm = require("vm");
const ELLIPSIS_CHANGE_MILLIS = 50;
let ReplService = class ReplService {
    constructor(server, logger, meta, ormMeta) {
        this.server = server;
        this.logger = logger;
        this.meta = meta;
        this.ormMeta = ormMeta;
    }
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            this.makeContext();
            cin_1.cin.getNative();
            this.loopPromise = this.repl();
        });
    }
    proxyModel(model) {
        let proxy_handler = {
            get: (target, name, receiver) => {
                if (!(name in target) && (name in target.db)) {
                    this.logger.warn(`${name} is not a property on ${target.name || target}. Forwarding call to ${target.name || target}.db`);
                    let value = target.db[name];
                    if (typeof value === 'function')
                        value = value.bind(target.db);
                    return value;
                }
                return target[name];
            }
        };
        let proxy = new Proxy(model, proxy_handler);
        proxy.toString = Function.prototype.toString.bind(model);
        return proxy;
    }
    makeContext() {
        this.context = vm.createContext();
        let models = this.ormMeta.models;
        if (models) {
            for (let q = 0; q < models.length; q++) {
                this.context[models[q].name] = this.proxyModel(models[q]);
            }
        }
        let services = this.meta.services;
        if (services) {
            for (let q = 0; q < services.length; q++) {
                this.context[services[q].name] = this.server.injector.resolveInjectable(services[q]);
            }
        }
        this.context['Server'] = this.server;
        this.context['Injector'] = this.server.injector;
        this.context['logger'] = this.logger;
        this.context['delay'] = delay_1.delay;
        this.context['require'] = require;
    }
    resolvePromise(promise) {
        return __awaiter(this, void 0, void 0, function* () {
            cin_1.cin.pause();
            let resolved = false, error = false;
            let result;
            promise.then(val => {
                resolved = true;
                result = val;
            }, err => {
                error = true;
                result = err;
            });
            let ticks = 0;
            while (!resolved && !error) {
                let dots = (ticks / 5) % 4;
                let line = `Resolving${'.'.repeat(dots)}`;
                cout_1.cout.write(line);
                yield delay_1.delay(ELLIPSIS_CHANGE_MILLIS);
                cout_1.cout.clearLine();
                cout_1.cout.moveCursor(-line.length, 0);
                ticks++;
            }
            cin_1.cin.resume();
            if (error)
                throw result;
            return result;
        });
    }
    execute(code) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let script = new vm.Script(code);
                let result = script.runInContext(this.context);
                if (result && result.then)
                    result = yield this.resolvePromise(result);
                direct_logger_1.directLogger.log(result);
            }
            catch (e) {
                this.logger.error(e && (e.message || e));
            }
        });
    }
    repl() {
        return __awaiter(this, void 0, void 0, function* () {
            while (true) {
                let line = yield cin_1.cin.readline();
                if (line == 'exit')
                    break;
                yield this.execute(line);
            }
        });
    }
    stop() {
        return __awaiter(this, void 0, void 0, function* () {
            cin_1.cin.emit('exit');
            yield this.loopPromise;
        });
    }
};
ReplService = __decorate([
    service_decorator_1.Service(),
    name_decorator_1.Name('repl'),
    __metadata("design:paramtypes", [server_1.Server,
        logger_1.Logger,
        server_2.ServerMetadata,
        orm_1.OrmMetadata])
], ReplService);
exports.ReplService = ReplService;
//# sourceMappingURL=repl.service.js.map