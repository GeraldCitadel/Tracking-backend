"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const injector_1 = require("../core/injector");
const injectable_decorator_1 = require("../decorators/services/injectable.decorator");
const name_decorator_1 = require("../decorators/services/name.decorator");
const server_1 = require("../metadata/server/server");
const logger_1 = require("../services/logger");
let ServiceReflector = class ServiceReflector {
    constructor(injector, serverMeta, logger) {
        this.injector = injector;
        this.serverMeta = serverMeta;
        this.logger = logger;
        this._reflectedServices = [];
        this._startedServices = [];
    }
    reflectServices(services) {
        if (typeof services === 'undefined')
            services = this.serverMeta.services;
        this.reflectServicesImpl(services || []);
    }
    reflectServicesImpl(services) {
        for (let serviceCtor of services) {
            this.reflectService(serviceCtor);
        }
    }
    reflectService(serviceFn) {
        let serviceName = serviceFn.name || serviceFn;
        try {
            let service = this.injector.resolveInjectable(serviceFn);
            if (typeof service === 'undefined')
                throw new Error(`Failed to inject service: ${serviceName}`);
            this._reflectedServices.push(service);
        }
        catch (e) {
            this.logger.error(`Exception occurred when trying to inject service: ${serviceName}`);
            this.logger.error(e);
        }
    }
    startServices() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._reflectedServices || !this._reflectedServices.length)
                return true;
            this.logger.verbose(`Starting services...`);
            let result = yield this.startServicesImpl();
            this.logger.info(`Finished starting services.`);
            return result;
        });
    }
    startServicesImpl() {
        return __awaiter(this, void 0, void 0, function* () {
            let services = this._reflectedServices;
            this._reflectedServices = [];
            let failures = 0;
            for (let service of services) {
                let serviceName = service.constructor.name || service.constructor;
                let result = yield this.startService(service);
                if (!result) {
                    this.logger.error(`Failed to start service: ${serviceName}`);
                    failures++;
                }
            }
            if (!!failures) {
                this.logger.error(`${services.length - failures} services started correctly out of ${services.length}`);
                return false;
            }
            else {
                this.logger.info(`${services.length - failures} services started correctly out of ${services.length}`);
                return true;
            }
        });
    }
    startService(service) {
        return __awaiter(this, void 0, void 0, function* () {
            let serviceName = service.constructor.name || service.constructor;
            try {
                let result = yield service.start();
                if (typeof result === 'boolean' && !result)
                    return false;
                this._startedServices.push(service);
                return true;
            }
            catch (e) {
                this.logger.error(`Exception occurred when trying to start service: ${serviceName}`);
                this.logger.error(e);
                return false;
            }
        });
    }
    listenServices(webServer) {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger.verbose(`Sending services 'listen' lifecycle hook...`);
            let result = yield this.listenServicesImpl(webServer);
            this.logger.verbose(`Finished sending services 'listen' lifecycle hook.`);
            return result;
        });
    }
    listenServicesImpl(webServer) {
        return __awaiter(this, void 0, void 0, function* () {
            let services = [...this._startedServices];
            let failures = 0;
            for (let q = 0; q < services.length; q++) {
                let result = yield this.listenService(services[q], webServer);
                if (!result) {
                    this.logger.error(`Failed to send 'listen' lifecycle hook for service: ${services[q]}`);
                    failures++;
                }
            }
            if (!!failures) {
                this.logger.error(`${services.length - failures} services recieved 'listen' lifecycle hook correctly out of ${services.length}`);
                return false;
            }
            else {
                this.logger.verbose(`${services.length - failures} services recieved 'listen' lifecycle hook correctly out of ${services.length}`);
                return true;
            }
        });
    }
    listenService(service, webServer) {
        return __awaiter(this, void 0, void 0, function* () {
            let serviceName = `${service}`;
            try {
                if (typeof service.listen !== 'undefined')
                    yield service.listen(webServer);
                return true;
            }
            catch (e) {
                this.logger.error(`Exception occurred when trying to stop service: ${serviceName}`);
                this.logger.error(e);
                return false;
            }
        });
    }
    shutdownServices() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._startedServices || !this._startedServices.length)
                return true;
            this.logger.verbose(`Shutting down services...`);
            let result = yield this.shutdownServicesImpl();
            this.logger.info(`Finished shutting down services.`);
            return result;
        });
    }
    shutdownServicesImpl() {
        return __awaiter(this, void 0, void 0, function* () {
            let services = this._startedServices;
            this._startedServices = [];
            let failures = 0;
            for (let q = 0; q < services.length; q++) {
                let result = yield this.shutdownService(services[q]);
                if (!result) {
                    this.logger.error(`Failed to stop service: ${services[q]}`);
                    failures++;
                }
            }
            if (!!failures) {
                this.logger.error(`${services.length - failures} services terminated correctly out of ${services.length}`);
                return false;
            }
            else {
                this.logger.info(`${services.length - failures} services terminated correctly out of ${services.length}`);
                return true;
            }
        });
    }
    shutdownService(service) {
        return __awaiter(this, void 0, void 0, function* () {
            let serviceName = `${service}`;
            try {
                if (typeof service.stop !== 'undefined')
                    yield service.stop();
                return true;
            }
            catch (e) {
                this.logger.error(`Exception occurred when trying to stop service: ${serviceName}`);
                this.logger.error(e);
                return false;
            }
        });
    }
};
ServiceReflector = __decorate([
    injectable_decorator_1.Injectable(),
    name_decorator_1.Name('services'),
    __metadata("design:paramtypes", [injector_1.Injector,
        server_1.ServerMetadata,
        logger_1.Logger])
], ServiceReflector);
exports.ServiceReflector = ServiceReflector;
//# sourceMappingURL=reflector.js.map