"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const sinon = require("sinon");
const sinonChai = require("sinon-chai");
chai_1.use(sinonChai);
const transaction_service_1 = require("../transaction.service");
const logger_core_1 = require("../logger-core");
const injector_1 = require("../../core/injector");
const server_1 = require("../../metadata/server");
const orm_service_1 = require("../orm.service");
const fake_orm_service_1 = require("./fake-orm.service");
const reflector_1 = require("../../router/reflector");
const fake_reflector_1 = require("../../router/test/fake-reflector");
describe('TransactionService', () => {
    let transactService;
    beforeEach(() => {
        let loggerCore = new logger_core_1.LoggerCore('abc', 'error', false);
        let injector = new injector_1.Injector(loggerCore);
        injector.provide({ provide: server_1.ServerMetadata, useValue: { name: 'abc' } });
        injector.provide({ provide: orm_service_1.ORMService, useClass: fake_orm_service_1.FakeORMService });
        injector.provide({ provide: reflector_1.RouterReflector, useClass: fake_reflector_1.FakeRouterReflector });
        transactService = injector.resolveInjectable(transaction_service_1.TransactionService);
    });
    it('should start with no transaction', () => {
        chai_1.expect(transactService.current).to.be.undefined;
    });
    describe('.run', () => {
        it('should not have a transaction after the asynchronous task completes', () => __awaiter(this, void 0, void 0, function* () {
            chai_1.expect(transactService.current).to.be.undefined;
            yield transactService.run(`test0`, () => __awaiter(this, void 0, void 0, function* () {
                chai_1.expect(transactService.current).not.to.be.undefined;
            }));
            chai_1.expect(transactService.current).to.be.undefined;
        }));
        it('should nest transactions by default', () => __awaiter(this, void 0, void 0, function* () {
            yield transactService.run(`test0`, () => __awaiter(this, void 0, void 0, function* () {
                chai_1.expect(transactService.current.fullName).to.match(/test0/i);
                yield transactService.run(`test1`, () => __awaiter(this, void 0, void 0, function* () {
                    chai_1.expect(transactService.current.fullName).to.match(/test0.*test1/i);
                }));
            }));
        }));
        it('should not nest transactions by if detach = true', () => __awaiter(this, void 0, void 0, function* () {
            yield transactService.run(`test0`, () => __awaiter(this, void 0, void 0, function* () {
                chai_1.expect(transactService.current.fullName).to.match(/test0/i);
                yield transactService.run(`test1`, true, () => __awaiter(this, void 0, void 0, function* () {
                    chai_1.expect(transactService.current.fullName).not.to.match(/test0.*test1/i);
                }));
            }));
        }));
        it('should persist a transaction after an asynchronous operation', (done) => {
            transactService.run(`test0`, () => __awaiter(this, void 0, void 0, function* () {
                let transact = transactService.current;
                chai_1.expect(transact).not.to.be.undefined;
                setTimeout(() => {
                    chai_1.expect(transact).to.eql(transact);
                    done();
                }, 10);
            }));
        });
        it('should return a promise that resolves to the result of the function', () => __awaiter(this, void 0, void 0, function* () {
            let result = yield transactService.run(`test0`, () => __awaiter(this, void 0, void 0, function* () {
                return 42;
            }));
            chai_1.expect(result).to.eql(42);
        }));
        it('should commit the transaction when the task completes successfully', () => __awaiter(this, void 0, void 0, function* () {
            let transact = void (0);
            let stubbed = {};
            yield transactService.run(`test0`, () => __awaiter(this, void 0, void 0, function* () {
                transact = transactService.current;
                chai_1.expect(transact.isComplete).to.be.false;
                stubbed.commit = sinon.stub(transact, 'commit').callThrough();
                stubbed.rollback = sinon.stub(transact, 'rollback').callThrough();
            }));
            chai_1.expect(transact.isComplete).to.be.true;
            chai_1.expect(transact.commit).to.have.been.calledOnce;
            chai_1.expect(transact.rollback).not.to.have.been.called;
            stubbed.commit.restore();
            stubbed.rollback.restore();
        }));
        it('should rollback the transaction when the task throws an exception', () => __awaiter(this, void 0, void 0, function* () {
            let transact = void (0);
            let stubbed = {};
            try {
                yield transactService.run(`test0`, () => __awaiter(this, void 0, void 0, function* () {
                    transact = transactService.current;
                    chai_1.expect(transact.isComplete).to.be.false;
                    stubbed.commit = sinon.stub(transact, 'commit').callThrough();
                    stubbed.rollback = sinon.stub(transact, 'rollback').callThrough();
                    throw new Error('Forced!');
                }));
            }
            catch (e) { }
            chai_1.expect(transact.isComplete).to.be.true;
            chai_1.expect(transact.commit).not.to.have.been.called;
            chai_1.expect(transact.rollback).to.have.been.calledOnce;
            stubbed.commit.restore();
            stubbed.rollback.restore();
        }));
    });
});
//# sourceMappingURL=transaction.service.spec.js.map