"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const sinon = require("sinon");
const sinonChai = require("sinon-chai");
chai_1.use(sinonChai);
const reflector_1 = require("../reflector");
const logger_core_1 = require("../logger-core");
const injector_1 = require("../../core/injector");
const server_1 = require("../../metadata/server/server");
const service_decorator_1 = require("../../decorators/services/service.decorator");
let NoLifecycleService = class NoLifecycleService {
    start() {
        return __awaiter(this, void 0, void 0, function* () { });
    }
};
NoLifecycleService = __decorate([
    service_decorator_1.Service()
], NoLifecycleService);
let LifecycleWorkService = class LifecycleWorkService {
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            return true;
        });
    }
    stop() {
        return __awaiter(this, void 0, void 0, function* () { });
    }
};
LifecycleWorkService = __decorate([
    service_decorator_1.Service()
], LifecycleWorkService);
let LifecycleWork2Service = class LifecycleWork2Service extends LifecycleWorkService {
};
LifecycleWork2Service = __decorate([
    service_decorator_1.Service()
], LifecycleWork2Service);
let LifecycleWork3Service = class LifecycleWork3Service extends LifecycleWorkService {
};
LifecycleWork3Service = __decorate([
    service_decorator_1.Service()
], LifecycleWork3Service);
let LifecycleFailService = class LifecycleFailService {
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            return false;
        });
    }
    stop() {
        return __awaiter(this, void 0, void 0, function* () { });
    }
};
LifecycleFailService = __decorate([
    service_decorator_1.Service()
], LifecycleFailService);
let LifecycleThrowStartService = class LifecycleThrowStartService {
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('Throwing up!');
        });
    }
    stop() {
        return __awaiter(this, void 0, void 0, function* () { });
    }
};
LifecycleThrowStartService = __decorate([
    service_decorator_1.Service()
], LifecycleThrowStartService);
let LifecycleThrowStopService = class LifecycleThrowStopService {
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            return true;
        });
    }
    stop() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('Throwing up!');
        });
    }
};
LifecycleThrowStopService = __decorate([
    service_decorator_1.Service()
], LifecycleThrowStopService);
describe('ServiceReflector', () => {
    let injector;
    let serviceReflector;
    beforeEach(() => {
        let loggerCore = new logger_core_1.LoggerCore('abc', 'error', false);
        injector = new injector_1.Injector(loggerCore);
        injector.provide({ provide: server_1.ServerMetadata, useValue: new server_1.ServerMetadata({ name: 'abc' }) });
        serviceReflector = injector.resolveInjectable(reflector_1.ServiceReflector);
    });
    describe('.reflectServices', () => {
        it('should not fail if no services are reflected', () => __awaiter(this, void 0, void 0, function* () {
            chai_1.expect(() => serviceReflector.reflectServices([])).not.to.throw;
        }));
        it('should not fail if services is not an array', () => __awaiter(this, void 0, void 0, function* () {
            chai_1.expect(() => serviceReflector.reflectServices(null)).not.to.throw;
        }));
        it('should invoke reflectService on each service passed in', () => __awaiter(this, void 0, void 0, function* () {
            sinon.stub(serviceReflector, 'reflectService');
            serviceReflector.reflectServices([
                LifecycleWorkService,
                LifecycleFailService
            ]);
            chai_1.expect(serviceReflector.reflectService).to.have.been.calledTwice;
        }));
    });
    describe('.reflectService', () => {
        let fn;
        beforeEach(() => {
            fn = serviceReflector.reflectService.bind(serviceReflector);
        });
        it(`should resolve the service using the server's injector`, () => __awaiter(this, void 0, void 0, function* () {
            sinon.stub(injector, 'resolveInjectable').callThrough();
            yield fn(NoLifecycleService);
            chai_1.expect(injector.resolveInjectable).to.have.been.calledOnce;
        }));
        it('should not fail if the injector fails to resolve the service', () => __awaiter(this, void 0, void 0, function* () {
            sinon.stub(injector, 'resolveInjectable').returns(null);
            yield fn(NoLifecycleService);
        }));
    });
    describe('.startServices', () => {
        it('should return true if no services have been reflected', () => __awaiter(this, void 0, void 0, function* () {
            serviceReflector.reflectServices([]);
            chai_1.expect(yield serviceReflector.startServices()).to.be.true;
            serviceReflector.reflectServices(null);
            chai_1.expect(yield serviceReflector.startServices()).to.be.true;
        }));
        it('should return true if no services fail to start', () => __awaiter(this, void 0, void 0, function* () {
            serviceReflector.reflectServices([
                LifecycleWorkService,
                LifecycleWork2Service,
                LifecycleWork3Service
            ]);
            chai_1.expect(yield serviceReflector.startServices()).to.be.true;
        }));
        it('should return false if any services fail to start', () => __awaiter(this, void 0, void 0, function* () {
            serviceReflector.reflectServices([
                LifecycleWorkService,
                LifecycleFailService
            ]);
            chai_1.expect(yield serviceReflector.startServices()).to.be.false;
        }));
    });
    describe('.startService', () => {
        let fn;
        beforeEach(() => {
            fn = serviceReflector.startService.bind(serviceReflector);
        });
        it(`should invoke the service's start function if it has one`, () => __awaiter(this, void 0, void 0, function* () {
            let lws = injector.resolveInjectable(LifecycleWorkService);
            let startStub = sinon.stub(lws, 'start').callThrough();
            yield fn(lws);
            chai_1.expect(lws.start).to.have.been.calledOnce;
        }));
        it('should return true if the service has no start function', () => __awaiter(this, void 0, void 0, function* () {
            let service = injector.resolveInjectable(NoLifecycleService);
            chai_1.expect(yield fn(service)).to.be.true;
        }));
        it('should return true if the service start function returns true', () => __awaiter(this, void 0, void 0, function* () {
            let service = injector.resolveInjectable(LifecycleWorkService);
            chai_1.expect(yield fn(service)).to.be.true;
        }));
        it('should return false if the service start function throws an error', () => __awaiter(this, void 0, void 0, function* () {
            let service = injector.resolveInjectable(LifecycleThrowStartService);
            chai_1.expect(yield fn(service)).to.be.false;
        }));
        it('should return false if the service start function returns false', () => __awaiter(this, void 0, void 0, function* () {
            let service = injector.resolveInjectable(LifecycleFailService);
            chai_1.expect(yield fn(service)).to.be.false;
        }));
    });
    describe('.shutdownServices', () => {
        it('should return true if no services are started', () => __awaiter(this, void 0, void 0, function* () {
            serviceReflector.reflectServices([]);
            yield serviceReflector.startServices();
            chai_1.expect(yield serviceReflector.shutdownServices()).to.be.true;
        }));
        it(`should return true if it doesn't fail to stop any services`, () => __awaiter(this, void 0, void 0, function* () {
            serviceReflector.reflectServices([
                LifecycleWorkService,
                LifecycleWork2Service,
                LifecycleWork3Service
            ]);
            yield serviceReflector.startServices();
            chai_1.expect(yield serviceReflector.shutdownServices()).to.be.true;
        }));
        it('should return false if it fails to stop any services', () => __awaiter(this, void 0, void 0, function* () {
            serviceReflector.reflectServices([
                LifecycleWorkService,
                LifecycleThrowStopService
            ]);
            yield serviceReflector.startServices();
            chai_1.expect(yield serviceReflector.shutdownServices()).to.be.false;
        }));
        it('should not shutdown a service that failed to start', () => __awaiter(this, void 0, void 0, function* () {
            let lts = injector.resolveInjectable(LifecycleThrowStartService);
            let stopStub = sinon.stub(lts, 'stop').callThrough();
            serviceReflector.reflectServices([LifecycleThrowStartService]);
            yield serviceReflector.startServices();
            chai_1.expect(yield serviceReflector.shutdownServices()).to.be.true;
            chai_1.expect(stopStub).not.to.have.been.called;
        }));
    });
    describe('.shutdownService', () => {
        let fn;
        beforeEach(() => {
            fn = serviceReflector.shutdownService.bind(serviceReflector);
        });
        it(`should invoke the service's stop function if it has one`, () => __awaiter(this, void 0, void 0, function* () {
            let lws = injector.resolveInjectable(LifecycleWorkService);
            let startStub = sinon.stub(lws, 'stop').callThrough();
            yield fn(lws);
            chai_1.expect(lws.stop).to.have.been.calledOnce;
        }));
        it('should return true if the service has no stop function', () => __awaiter(this, void 0, void 0, function* () {
            let nls = injector.resolveInjectable(NoLifecycleService);
            chai_1.expect(yield fn(nls)).to.be.true;
        }));
        it('should return true if the service stop function returns without throwing', () => __awaiter(this, void 0, void 0, function* () {
            let lws = injector.resolveInjectable(LifecycleWorkService);
            chai_1.expect(yield fn(lws)).to.be.true;
        }));
        it('should return false if the service stop function throws an error', () => __awaiter(this, void 0, void 0, function* () {
            let lts = injector.resolveInjectable(LifecycleThrowStopService);
            chai_1.expect(yield fn(lts)).to.be.false;
        }));
    });
});
//# sourceMappingURL=reflector.spec.js.map