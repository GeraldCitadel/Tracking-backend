"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const cls_namespace_service_1 = require("./cls-namespace.service");
const service_decorator_1 = require("../decorators/services/service.decorator");
const name_decorator_1 = require("../decorators/services/name.decorator");
const logger_1 = require("./logger");
const orm_service_1 = require("./orm.service");
const reflector_1 = require("../router/reflector");
let TransactionService = class TransactionService {
    constructor(orm, logger, namespace, routerReflector) {
        this.orm = orm;
        this.logger = logger;
        this.namespace = namespace;
        this.routerReflector = routerReflector;
    }
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            this.routerReflector.registerRouteInterceptor((req, res, next) => __awaiter(this, void 0, void 0, function* () {
                let requestIndex = req.requestIndex;
                let routeMethodName = req.routeMethodName;
                let transactionName = `{${requestIndex}}:${routeMethodName}`;
                yield this.run(transactionName, next);
            }));
        });
    }
    get current() {
        if (!this.orm)
            return undefined;
        return this.orm.currentTransaction;
    }
    run(transactionName, detach, fn) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof detach === 'function') {
                fn = detach;
                detach = false;
            }
            if (!this.orm) {
                this.logger.warn(`Someone attempted to create a transaction, but there is no ORMService. Running callback without a transaction.`);
                return yield fn();
            }
            return yield this.namespace.runAndReturn(() => __awaiter(this, void 0, void 0, function* () {
                let t = yield this.orm.transaction(transactionName, detach ? null : this.current);
                if (!t)
                    return yield fn();
                this.logger.verbose(`creating transaction (${t.fullName})`);
                let failed = false;
                try {
                    return yield fn();
                }
                catch (e) {
                    this.logger.error(`caught an exception in a transaction (${t.fullName}). Rolling back...`);
                    this.logger.verbose('exception details:', e);
                    if (t) {
                        if (t.isComplete)
                            this.logger.warn(`transaction (${t.fullName}) committed or rolled back inside transaction function. Cannot roll back.`);
                        else
                            yield t.rollback();
                    }
                    failed = true;
                    throw e;
                }
                finally {
                    if (!failed) {
                        this.logger.verbose(`committing transaction (${t.fullName})`);
                        if (t) {
                            if (t.isComplete)
                                this.logger.warn(`transaction (${t.fullName}) committed or rolled back inside transaction function. Cannot commit.`);
                            else
                                yield t.commit();
                        }
                    }
                }
            }));
        });
    }
};
TransactionService = __decorate([
    service_decorator_1.Service(),
    name_decorator_1.Name('transactions'),
    __metadata("design:paramtypes", [orm_service_1.ORMService,
        logger_1.Logger,
        cls_namespace_service_1.ClsNamespaceService,
        reflector_1.RouterReflector])
], TransactionService);
exports.TransactionService = TransactionService;
//# sourceMappingURL=transaction.service.js.map