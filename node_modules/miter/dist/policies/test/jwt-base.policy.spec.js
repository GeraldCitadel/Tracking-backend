"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const sinon = require("sinon");
const sinonChai = require("sinon-chai");
chai_1.use(sinonChai);
const jwt_base_policy_1 = require("../jwt-base.policy");
const logger_core_1 = require("../../services/logger-core");
const jwt_1 = require("../../metadata/server/jwt");
const fake_request_1 = require("../../router/test/fake-request");
const fake_response_1 = require("../../router/test/fake-response");
const http_status_type_1 = require("../../util/http-status-type");
const jwt = require("jsonwebtoken");
describe('JwtBasePolicy', () => {
    let ctor;
    let jwtBasePolicy;
    const testSecret = 'abracadabra';
    const testJwt = {
        id: 2,
        username: 'a fake user!'
    };
    let req;
    let res;
    let headerStub;
    beforeEach(() => {
        let logger = new logger_core_1.LoggerCore('abc', 'error', false);
        ctor = (jwtMeta, credentialsRequired) => {
            return jwtBasePolicy = new jwt_base_policy_1.JwtBasePolicy(jwtMeta && new jwt_1.JwtMetadata(jwtMeta), logger, credentialsRequired);
        };
        req = fake_request_1.FakeRequest();
        res = fake_response_1.FakeResponse();
        headerStub = undefined;
    });
    function stubHeader(name, val) {
        if (!headerStub) {
            headerStub = sinon.stub(req, 'header');
        }
        headerStub.withArgs(name).returns(val);
        req.headers[name] = val;
        req.headers[name.toLowerCase()] = val;
    }
    describe('.property', () => {
        it(`should return 'jwt' by default`, () => {
            ctor({ secret: testSecret }, false);
            chai_1.expect(jwtBasePolicy.property).to.eql('jwt');
        });
        it(`should return the value provided by the JwtMetadata`, () => {
            ctor({ secret: testSecret, tokenProperty: 'user' }, false);
            chai_1.expect(jwtBasePolicy.property).to.eql('user');
        });
        it('should return undefined if jwtMeta is falsey', () => {
            ctor(null, false);
            chai_1.expect(jwtBasePolicy.property).to.eql(undefined);
        });
    });
    describe('.credentialsRequired', () => {
        it(`should be the value passed into the constructor`, () => {
            ctor({ secret: testSecret }, true);
            chai_1.expect(jwtBasePolicy.credentialsRequired).to.be.true;
            ctor({ secret: testSecret }, false);
            chai_1.expect(jwtBasePolicy.credentialsRequired).to.be.false;
        });
    });
    describe('.handle', () => {
        describe('when jwtMeta is defined', () => {
            describe('when the jwt is null', () => {
                beforeEach(() => {
                    ctor({ secret: testSecret }, false);
                    sinon.stub(jwtBasePolicy, 'getJwt').returns(Promise.resolve(null));
                });
                it('should not invoke fromJson', () => __awaiter(this, void 0, void 0, function* () {
                    sinon.spy(jwtBasePolicy, 'fromJson');
                    yield jwtBasePolicy.handle(req, res);
                    chai_1.expect(jwtBasePolicy.fromJson).not.to.have.been.called;
                }));
                it('should return null', () => __awaiter(this, void 0, void 0, function* () {
                    let result = yield jwtBasePolicy.handle(req, res);
                    chai_1.expect(result).to.be.null;
                }));
                describe('when credentialsRequired = true', () => {
                    beforeEach(() => jwtBasePolicy.credentialsRequired = true);
                    it('should set the status to HTTP_STATUS_UNAUTHORIZED', () => __awaiter(this, void 0, void 0, function* () {
                        yield jwtBasePolicy.handle(req, res);
                        chai_1.expect(res.statusCode).to.eq(http_status_type_1.HTTP_STATUS_UNAUTHORIZED);
                    }));
                });
                describe('when credentialsRequired = false', () => {
                    it('should not set the status if the jwt is null', () => __awaiter(this, void 0, void 0, function* () {
                        yield jwtBasePolicy.handle(req, res);
                        chai_1.expect(res.statusCode).to.eq(0);
                    }));
                });
            });
            describe('when the jwt is not null', () => {
                beforeEach(() => {
                    ctor({ secret: testSecret }, false);
                    sinon.stub(jwtBasePolicy, 'getJwt').returns(Promise.resolve(testJwt));
                });
                it('should invoke fromJson with the jwt if it is not null', () => __awaiter(this, void 0, void 0, function* () {
                    sinon.spy(jwtBasePolicy, 'fromJson');
                    yield jwtBasePolicy.handle(req, res);
                    chai_1.expect(jwtBasePolicy.fromJson).to.have.been.calledOnce.calledWith(testJwt);
                }));
                it('should return the value returned by fromJson', () => __awaiter(this, void 0, void 0, function* () {
                    let testValue = 'fish!';
                    sinon.stub(jwtBasePolicy, 'fromJson').returns(Promise.resolve(testValue));
                    let result = yield jwtBasePolicy.handle(req, res);
                    chai_1.expect(result).to.eq(testValue);
                }));
                describe('when credentialsRequired = true', () => {
                    beforeEach(() => jwtBasePolicy.credentialsRequired = true);
                    it('should not set the status if the jwt is not null', () => __awaiter(this, void 0, void 0, function* () {
                        yield jwtBasePolicy.handle(req, res);
                        chai_1.expect(res.statusCode).to.eq(0);
                    }));
                });
                describe('when credentialsRequired = false', () => {
                    it('should not set the status if the jwt is not null', () => __awaiter(this, void 0, void 0, function* () {
                        yield jwtBasePolicy.handle(req, res);
                        chai_1.expect(res.statusCode).to.eq(0);
                    }));
                });
            });
        });
    });
    describe('.getJwt', () => {
        let getJwt;
        describe('when jwtMeta is undefined', () => {
            beforeEach(() => {
                ctor(undefined, false);
                getJwt = jwtBasePolicy.getJwt.bind(jwtBasePolicy);
            });
            it('should not invoke the jwt handler', () => __awaiter(this, void 0, void 0, function* () {
                if (!jwtBasePolicy.jwtHandler)
                    return;
                sinon.stub(jwtBasePolicy, 'jwtHandler');
                yield getJwt(req, res);
                chai_1.expect(jwtBasePolicy.jwtHandler).not.to.have.been.called;
            }));
            it('should return null', () => __awaiter(this, void 0, void 0, function* () {
                let result = yield getJwt(req, res);
                chai_1.expect(result).to.be.null;
            }));
        });
        describe('when jwtMeta is defined', () => {
            beforeEach(() => {
                ctor({ secret: testSecret }, false);
                getJwt = jwtBasePolicy.getJwt.bind(jwtBasePolicy);
            });
            it('should invoke the jwtHandler', () => __awaiter(this, void 0, void 0, function* () {
                sinon.spy(jwtBasePolicy, 'jwtHandler');
                yield getJwt(req, res);
                chai_1.expect(jwtBasePolicy.jwtHandler).to.have.been.calledOnce;
            }));
            it('should return null if there is no Authorization header', () => __awaiter(this, void 0, void 0, function* () {
                let result = yield getJwt(req, res);
                chai_1.expect(result).to.be.null;
            }));
            it('should return null if the Authorization header is invalid', () => __awaiter(this, void 0, void 0, function* () {
                stubHeader('Authorization', 'Bearer HAHA, NOPE!');
                let result = yield getJwt(req, res);
                chai_1.expect(result).to.be.null;
            }));
            it('should return the JWT json if the Authorization header is valid', () => __awaiter(this, void 0, void 0, function* () {
                let token = jwt.sign(testJwt, testSecret);
                stubHeader('Authorization', `Bearer ${token}`);
                let result = yield getJwt(req, res);
                if (result.iat)
                    delete result.iat;
                chai_1.expect(result).to.deep.eq(testJwt);
            }));
            it('should log verbose if the jwt handler throws an error', () => __awaiter(this, void 0, void 0, function* () {
                sinon.stub(jwtBasePolicy, 'jwtHandler').throws('HAHA die!');
                let stub = sinon.stub(jwtBasePolicy.logger, 'verbose');
                yield getJwt(req, res);
                chai_1.expect(stub).to.have.been.calledTwice;
            }));
            it('should return null if the jwt handler throws an error', () => __awaiter(this, void 0, void 0, function* () {
                sinon.stub(jwtBasePolicy, 'jwtHandler').throws('HAHA die!');
                let result = yield getJwt(req, res);
                chai_1.expect(result).to.be.null;
            }));
        });
    });
    describe('.fromJson', () => {
        let fromJson;
        beforeEach(() => {
            ctor({ secret: testSecret }, false);
            fromJson = jwtBasePolicy.fromJson.bind(jwtBasePolicy);
        });
        it('should return a promise', () => {
            chai_1.expect(fromJson(null)).to.be.an.instanceOf(Promise);
        });
        describe('that promise', () => {
            it('should resolve to the same passed-in value', () => __awaiter(this, void 0, void 0, function* () {
                function expectSame(val) {
                    return __awaiter(this, void 0, void 0, function* () {
                        let result = yield fromJson(val);
                        chai_1.expect(result).to.deep.eq(val);
                    });
                }
                ;
                yield expectSame(null);
                yield expectSame(undefined);
                yield expectSame({});
                yield expectSame({ id: 20, name: 'fake user!' });
            }));
        });
    });
});
//# sourceMappingURL=jwt-base.policy.spec.js.map