"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const wrap_promise_1 = require("../util/wrap-promise");
const static_send_files_1 = require("./static-send-files");
const template_service_1 = require("../services/template.service");
const http_status_type_1 = require("../util/http-status-type");
const pathStatic = require("path");
const pathJoin = pathStatic.join.bind(pathStatic);
function monkeypatchResponseSendFile(req, res, next) {
    let origSendFile = res.sendFile;
    res.sendfile = res.sendFile = (path, options, errback) => __awaiter(this, void 0, void 0, function* () {
        if (!errback && typeof options === 'function') {
            errback = options;
            options = undefined;
        }
        if (errback)
            origSendFile(path, options, errback);
        else
            yield wrap_promise_1.wrapPromise(origSendFile.bind(res), path, options);
    });
    res.sendFiles = static_send_files_1.sendFiles;
    next();
}
exports.monkeypatchResponseSendFile = monkeypatchResponseSendFile;
function monkeypatchResponseRender(injector, app) {
    return function (req, res, next) {
        let origRender = res.render;
        res.render = (path, opts, errback) => __awaiter(this, void 0, void 0, function* () {
            let root = app.get('views');
            if (root && !path.startsWith('/'))
                path = pathJoin(root, path);
            let templateService = injector.resolveInjectable(template_service_1.TemplateService);
            if (!templateService)
                throw new Error(`Cannot render using the miter view engine. No TemplateService provided`);
            let result = yield templateService.render(path, opts);
            res.status(http_status_type_1.HTTP_STATUS_OK).send(result);
        });
        next();
    };
}
exports.monkeypatchResponseRender = monkeypatchResponseRender;
//# sourceMappingURL=static-middleware.js.map