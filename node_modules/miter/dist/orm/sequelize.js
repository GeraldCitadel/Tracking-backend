"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const injectable_decorator_1 = require("../decorators/services/injectable.decorator");
const name_decorator_1 = require("../decorators/services/name.decorator");
const orm_1 = require("../metadata/server/orm");
const database_1 = require("../metadata/server/database");
const logger_1 = require("../services/logger");
const logger_core_1 = require("../services/logger-core");
const cls_namespace_service_1 = require("../services/cls-namespace.service");
const transaction_impl_1 = require("./impl/transaction-impl");
const __Sequelize = require("sequelize");
let Sequelize = class Sequelize {
    constructor(ormMeta, dbMeta, loggerCore, logger, namespace) {
        this.ormMeta = ormMeta;
        this.dbMeta = dbMeta;
        this.loggerCore = loggerCore;
        this.logger = logger;
        this.namespace = namespace;
        this._initialized = false;
        this.sqlLogger = logger_1.Logger.fromSubsystem(this.loggerCore, 'sql');
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._initialized)
                return;
            this._initialized = true;
            if (!this.ormMeta.enabled || !this.dbMeta)
                return;
            let db = this.dbMeta;
            this.sql = new __Sequelize(db.name, db.user, db.password, {
                host: db.host.domain,
                port: db.host.port,
                dialect: db.dialect,
                dialectOptions: {
                    charset: db.charset
                },
                pool: db.pool,
                define: {
                    charset: db.charset,
                    collate: `${db.charset}_general_ci`
                },
                logging: (msg, ...extras) => this.sqlLogger.verbose(msg, ...extras)
            });
        });
    }
    sync() {
        return __awaiter(this, void 0, void 0, function* () {
            let recreate = (this.ormMeta.recreate) || false;
            if (recreate) {
                if ((process.env.NODE_ENV || '') == 'production')
                    throw new Error('Server launched with config value orm.recreate enabled. As a security feature, this causes a crash when NODE_ENV = production.');
                this.logger.warn(`Warning: recreating database tables. Note: this option should not be enabled in production.`);
            }
            if (!this.sql)
                throw new Error(`Cannot sync the database: the ORM is disabled.`);
            return yield this.sql.sync({ force: recreate });
        });
    }
    define(modelName, attributes, options) {
        if (!this.sql)
            throw new Error(`Cannot define new models: the ORM is disabled.`);
        return this.sql.define(modelName, attributes, options);
    }
    get currentTransaction() {
        return this.namespace.get('transaction');
    }
    set currentTransaction(val) {
        this.namespace.set('transaction', val);
    }
    transaction(transactionName, transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            let parentTransaction = transaction;
            if (typeof parentTransaction === 'undefined')
                parentTransaction = this.currentTransaction;
            if (!this.sql)
                return parentTransaction || undefined;
            let sqlTransact = parentTransaction && parentTransaction.sync();
            if (!sqlTransact)
                sqlTransact = yield this.sql.transaction();
            else
                sqlTransact = yield this.sql.transaction({ transaction: sqlTransact });
            let t = new transaction_impl_1.TransactionImpl(transactionName, sqlTransact, parentTransaction || null);
            this.currentTransaction = t;
            return t;
        });
    }
};
Sequelize = __decorate([
    injectable_decorator_1.Injectable(),
    name_decorator_1.Name('orm'),
    __metadata("design:paramtypes", [orm_1.OrmMetadata,
        database_1.DatabaseMetadata,
        logger_core_1.LoggerCore,
        logger_1.Logger,
        cls_namespace_service_1.ClsNamespaceService])
], Sequelize);
exports.Sequelize = Sequelize;
//# sourceMappingURL=sequelize.js.map